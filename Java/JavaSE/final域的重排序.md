# final域的重排序（读书笔记）

## final域的重排序规则

对于final域，编译器和处理器都要遵守两个重排序规则：

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

## 写final域的重排序规则

写final域的重排序规则 **禁止** 把final域的写重排序到构造函数之外。这个规则的实现包含下面两个方面。

1. JMM禁止编译器把final域的写重排序到构造函数之外。
2. 编译器会在final域的写之后，构造函数return之前，插入一个`StoreStore`屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。

写final域的重排序规则可以确保：**在对象引用为任意线程可见之前，对象的final域已经被正确初始化了，而普通域不具有这个保障。**

## 读final域的重排序规则

读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意：这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个`LoadLoad`屏障。

读final域的重排序规则可以确保：**在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。**

## final域为引用类型

对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

## More: concurrent包的通用化实现模式：

1. 声明共享变量为`volatile`

2. 使用`CAS`的原子条件更新来实现线程之间同步

3. 配合以`volatile`的读/写和`CAS`所具有多的`volatile`读和写的内存语义来实现线程之间的通信。

所谓`CAS`，就是`Compare And Set`，反应到Java里就是这样一个函数：
```Java
public final native boolean compareAndSwapXXX(Object var1, long var2, int var4, int var5);
```
