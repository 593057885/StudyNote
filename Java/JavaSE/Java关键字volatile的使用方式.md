# Java关键字volatile的使用

## 作用

强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。

使用volatile关键字增加了实例变量在多个线程之间的可见性。但是volatile最致命的缺点是不支持原子性。

## volatile与synchronized的比较

1. 关键字volatile是线程同步的**轻量级**实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰变量，而synchronized可以修饰方法，以及代码块。

2. 多线程访问volatile不会出现阻塞，而synchronized会出现阻塞

3. volatile能保证数据的可见性，但不保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会**将私有内存和公共内存中的数据进行同步**。

## volatile非原子的特性

关键字volatile主要使用的场景是在多个线程中可以感知实例变量被更改了，并且可以获得最新的值使用，也就是**多线程读取共享变量时可以获得最新值使用。**

关键字volatile提示线程每次从共享内存中读取变量，而不是从私有内存中读取，这样就保证了同步数据的可见性。

如果修改实例变量中的数据，比如i++，也就是i = i + 1，则这样的操作其实并不是一个原子操作，也就是非线程安全的。

表达式i++的操作步骤分解如下：

1. 从内存中取出i的值
2. 计算i的值
3. 将i的值写到内存中

如果在第二步计算值的时候，另一个线程也修改i的值，那么这个时候就会出现脏数据。解决的办法是使用使用synchronized关键字，保证同一时刻只有一个线程可以操作该数据。

volatile本身并不处理数据的原子性，而是强制对数据的读写及时影响到内存中。

变量在内存中工作的过程如图：

![pic](https://www.processon.com/chart_image/581c4688e4b0e44947566072.png)

由上图，可以得出以下结论：

1. read和load阶段：从主存复制变量到当前线程工作内存

2. use和assign阶段：执行代码，改变共享变量值

3. store和write阶段：用工作内存数据刷新主存对应变量的值

在多线程环境中，use和assign是多次出现的，但这一操作并不是原子性，也就是在read和load之后，如果主内存count变量发生修改之后，线程工作内存中的值已经加载，不会产生对应的变化，也就是私有内存和公共内存中的变量不同步，所以计算出来的结果会和预期不一样，也就是出现了非线程安全问题。

对于volatile修饰的变量，JVM虚拟机只是保证从主内存加载到线程工作内存的值是最新的。也就是说，volatile关键字解决的是变量读时的可见性问题，但无法保证原子性，对于多个线程访问同一个实例变量还是需要加锁同步。
